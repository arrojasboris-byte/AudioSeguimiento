/** AudioSeguimiento · Backend Cloud (Google Apps Script)
 *  Guarda TODO el dataset como un único JSON en la hoja.
 *  Bloqueo de edición (TTL 15 min) para evitar ediciones simultáneas.
 */

const SHEET_NAME = 'data';
const LOCK_TTL_MIN = 15;

function _sheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) {
    sh = ss.insertSheet(SHEET_NAME);
    sh.getRange(1,1,1,6).setValues([['key','json','lock_user','lock_until','updated_at','version']]);
    sh.getRange(2,1).setValue('main');
  }
  return sh;
}

function _nowISO(){ return new Date().toISOString(); }
function _addMins(d,mins){ return new Date(d.getTime()+mins*60000); }

function _readRow() {
  const sh=_sheet();
  const r=sh.getRange(2,1,1,6).getValues()[0];
  return { key:r[0]||'main', json:r[1]||'', lock_user:r[2]||'', lock_until:r[3]||'', updated_at:r[4]||'', version:r[5]||'v' };
}

function _writeJSON(json) {
  const sh=_sheet(); const now=_nowISO();
  sh.getRange(2,2,1,3).setValues([[json,'','']]); // json, lock_user, lock_until (unlock al guardar)
  sh.getRange(2,5).setValue(now); // updated_at
  return now;
}

function _setLock(user) {
  const sh=_sheet();
  const row=_readRow();
  const until = _addMins(new Date(), LOCK_TTL_MIN).toISOString();
  // si hay lock válido y no es del mismo user -> no bloquear
  if (row.lock_user && row.lock_until && new Date(row.lock_until) > new Date() && row.lock_user !== user) {
    return { ok:false, locked_by: row.lock_user, until: row.lock_until };
  }
  sh.getRange(2,3,1,2).setValues([[user, until]]); // lock_user, lock_until
  return { ok:true, locked_by:user, until };
}

function _clearLock(user) {
  const sh=_sheet();
  const row=_readRow();
  if (!row.lock_user || row.lock_user === user || new Date(row.lock_until) < new Date()) {
    sh.getRange(2,3,1,2).setValues([['','']]); // unlock
    return { ok:true };
  }
  return { ok:false, locked_by: row.lock_user, until: row.lock_until };
}

function _cors(resp) {
  return ContentService
    .createTextOutput(resp)
    .setMimeType(ContentService.MimeType.JSON)
    .setHeader('Access-Control-Allow-Origin','*')
    .setHeader('Access-Control-Allow-Methods','GET,POST,OPTIONS')
    .setHeader('Access-Control-Allow-Headers','Content-Type');
}

function doOptions(e){ return _cors(JSON.stringify({ok:true})); }

function doGet(e) {
  const p = e && e.parameter || {};
  const row=_readRow();
  if (p.action==='status') {
    return _cors(JSON.stringify({
      ok:true,
      updated_at: row.updated_at || '',
      lock_user: row.lock_user || '',
      lock_until: row.lock_until || ''
    }));
  }
  // default: load
  const json = row.json || JSON.stringify({}); // si vacío, objeto vacío
  return _cors(json);
}

function doPost(e) {
  try {
    const body = JSON.parse(e.postData.contents || '{}');
    const act = body.action || 'save';
    if (act==='lock') {
      const res = body.mode==='unlock' ? _clearLock(body.user||'') : _setLock(body.user||'');
      return _cors(JSON.stringify(res));
    }
    if (act==='save') {
      const json = JSON.stringify(body.data || {});
      const ts = _writeJSON(json);
      return _cors(JSON.stringify({ok:true, updated_at: ts}));
    }
    return _cors(JSON.stringify({ok:false, error:'acción no soportada'}));
  } catch (err) {
    return _cors(JSON.stringify({ok:false, error:String(err)}));
  }
}
